{
  "version": 3,
  "sources": ["../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/webpack/universalModuleDefinition", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/webpack/bootstrap", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/lodash/isObject.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/lodash/debounce.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/lodash/throttle.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/lodash/_root.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/lodash/_Symbol.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/smoothscroll-polyfill/dist/smoothscroll.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/tabbable/index.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/lodash/now.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/lodash/_freeGlobal.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/(webpack)/buildin/global.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/lodash/toNumber.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/lodash/_baseTrim.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/lodash/_trimmedEndIndex.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/lodash/isSymbol.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/lodash/_baseGetTag.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/lodash/_getRawTag.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/lodash/_objectToString.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/lodash/isObjectLike.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/node_modules/element-closest/index.mjs", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/helpers/toArray.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/helpers/qsa.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/helpers/getElements.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/helpers/hasOwnProperty.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/helpers/isObject.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/helpers/minmax.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/helpers/passive.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/helpers/pick.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/helpers/values.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/snap-slider.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/helpers/getStyle.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/helpers/getClosestAttribute.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/helpers/onReady.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/helpers/on.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/helpers/dashes.js", "../../../node_modules/@tannerhodges/snap-slider/webpack:/SnapSlider/src/modules/logger.js", "../../../assets/js/site.js"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SnapSlider\"] = factory();\n\telse\n\t\troot[\"SnapSlider\"] = factory();\n})(window, function() {\nreturn ", " \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 18);\n", "/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n", "var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n", "var debounce = require('./debounce'),\n    isObject = require('./isObject');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n", "var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n", "var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n", "/* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n(function () {\n  'use strict';\n\n  // polyfill\n  function polyfill() {\n    // aliases\n    var w = window;\n    var d = document;\n\n    // return if scroll behavior is supported and polyfill is not forced\n    if (\n      'scrollBehavior' in d.documentElement.style &&\n      w.__forceSmoothScrollPolyfill__ !== true\n    ) {\n      return;\n    }\n\n    // globals\n    var Element = w.HTMLElement || w.Element;\n    var SCROLL_TIME = 468;\n\n    // object gathering original scroll methods\n    var original = {\n      scroll: w.scroll || w.scrollTo,\n      scrollBy: w.scrollBy,\n      elementScroll: Element.prototype.scroll || scrollElement,\n      scrollIntoView: Element.prototype.scrollIntoView\n    };\n\n    // define timing method\n    var now =\n      w.performance && w.performance.now\n        ? w.performance.now.bind(w.performance)\n        : Date.now;\n\n    /**\n     * indicates if a the current browser is made by Microsoft\n     * @method isMicrosoftBrowser\n     * @param {String} userAgent\n     * @returns {Boolean}\n     */\n    function isMicrosoftBrowser(userAgent) {\n      var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n\n      return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n    }\n\n    /*\n     * IE has rounding bug rounding down clientHeight and clientWidth and\n     * rounding up scrollHeight and scrollWidth causing false positives\n     * on hasScrollableSpace\n     */\n    var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n\n    /**\n     * changes scroll position inside an element\n     * @method scrollElement\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function scrollElement(x, y) {\n      this.scrollLeft = x;\n      this.scrollTop = y;\n    }\n\n    /**\n     * returns result of applying ease math function to a number\n     * @method ease\n     * @param {Number} k\n     * @returns {Number}\n     */\n    function ease(k) {\n      return 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n\n    /**\n     * indicates if a smooth behavior should be applied\n     * @method shouldBailOut\n     * @param {Number|Object} firstArg\n     * @returns {Boolean}\n     */\n    function shouldBailOut(firstArg) {\n      if (\n        firstArg === null ||\n        typeof firstArg !== 'object' ||\n        firstArg.behavior === undefined ||\n        firstArg.behavior === 'auto' ||\n        firstArg.behavior === 'instant'\n      ) {\n        // first argument is not an object/null\n        // or behavior is auto, instant or undefined\n        return true;\n      }\n\n      if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {\n        // first argument is an object and behavior is smooth\n        return false;\n      }\n\n      // throw error when behavior is not supported\n      throw new TypeError(\n        'behavior member of ScrollOptions ' +\n          firstArg.behavior +\n          ' is not a valid value for enumeration ScrollBehavior.'\n      );\n    }\n\n    /**\n     * indicates if an element has scrollable space in the provided axis\n     * @method hasScrollableSpace\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function hasScrollableSpace(el, axis) {\n      if (axis === 'Y') {\n        return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n      }\n\n      if (axis === 'X') {\n        return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n      }\n    }\n\n    /**\n     * indicates if an element has a scrollable overflow property in the axis\n     * @method canOverflow\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function canOverflow(el, axis) {\n      var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n\n      return overflowValue === 'auto' || overflowValue === 'scroll';\n    }\n\n    /**\n     * indicates if an element can be scrolled in either axis\n     * @method isScrollable\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function isScrollable(el) {\n      var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n      var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n\n      return isScrollableY || isScrollableX;\n    }\n\n    /**\n     * finds scrollable parent of an element\n     * @method findScrollableParent\n     * @param {Node} el\n     * @returns {Node} el\n     */\n    function findScrollableParent(el) {\n      while (el !== d.body && isScrollable(el) === false) {\n        el = el.parentNode || el.host;\n      }\n\n      return el;\n    }\n\n    /**\n     * self invoked function that, given a context, steps through scrolling\n     * @method step\n     * @param {Object} context\n     * @returns {undefined}\n     */\n    function step(context) {\n      var time = now();\n      var value;\n      var currentX;\n      var currentY;\n      var elapsed = (time - context.startTime) / SCROLL_TIME;\n\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n\n      // apply easing to elapsed time\n      value = ease(elapsed);\n\n      currentX = context.startX + (context.x - context.startX) * value;\n      currentY = context.startY + (context.y - context.startY) * value;\n\n      context.method.call(context.scrollable, currentX, currentY);\n\n      // scroll more if we have not reached our destination\n      if (currentX !== context.x || currentY !== context.y) {\n        w.requestAnimationFrame(step.bind(w, context));\n      }\n    }\n\n    /**\n     * scrolls window or element with a smooth behavior\n     * @method smoothScroll\n     * @param {Object|Node} el\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function smoothScroll(el, x, y) {\n      var scrollable;\n      var startX;\n      var startY;\n      var method;\n      var startTime = now();\n\n      // define scroll context\n      if (el === d.body) {\n        scrollable = w;\n        startX = w.scrollX || w.pageXOffset;\n        startY = w.scrollY || w.pageYOffset;\n        method = original.scroll;\n      } else {\n        scrollable = el;\n        startX = el.scrollLeft;\n        startY = el.scrollTop;\n        method = scrollElement;\n      }\n\n      // scroll looping over a frame\n      step({\n        scrollable: scrollable,\n        method: method,\n        startTime: startTime,\n        startX: startX,\n        startY: startY,\n        x: x,\n        y: y\n      });\n    }\n\n    // ORIGINAL METHODS OVERRIDES\n    // w.scroll and w.scrollTo\n    w.scroll = w.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scroll.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object'\n              ? arguments[0]\n              : w.scrollX || w.pageXOffset,\n          // use top prop, second argument if present or fallback to scrollY\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined\n              ? arguments[1]\n              : w.scrollY || w.pageYOffset\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left\n          : w.scrollX || w.pageXOffset,\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top\n          : w.scrollY || w.pageYOffset\n      );\n    };\n\n    // w.scrollBy\n    w.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scrollBy.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object' ? arguments[0] : 0,\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined ? arguments[1] : 0\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n        ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n      );\n    };\n\n    // Element.prototype.scroll and Element.prototype.scrollTo\n    Element.prototype.scroll = Element.prototype.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        // if one number is passed, throw error to match Firefox implementation\n        if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n          throw new SyntaxError('Value could not be converted');\n        }\n\n        original.elementScroll.call(\n          this,\n          // use left prop, first number argument or fallback to scrollLeft\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left\n            : typeof arguments[0] !== 'object' ? ~~arguments[0] : this.scrollLeft,\n          // use top prop, second argument or fallback to scrollTop\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top\n            : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop\n        );\n\n        return;\n      }\n\n      var left = arguments[0].left;\n      var top = arguments[0].top;\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        this,\n        this,\n        typeof left === 'undefined' ? this.scrollLeft : ~~left,\n        typeof top === 'undefined' ? this.scrollTop : ~~top\n      );\n    };\n\n    // Element.prototype.scrollBy\n    Element.prototype.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.elementScroll.call(\n          this,\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left + this.scrollLeft\n            : ~~arguments[0] + this.scrollLeft,\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top + this.scrollTop\n            : ~~arguments[1] + this.scrollTop\n        );\n\n        return;\n      }\n\n      this.scroll({\n        left: ~~arguments[0].left + this.scrollLeft,\n        top: ~~arguments[0].top + this.scrollTop,\n        behavior: arguments[0].behavior\n      });\n    };\n\n    // Element.prototype.scrollIntoView\n    Element.prototype.scrollIntoView = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scrollIntoView.call(\n          this,\n          arguments[0] === undefined ? true : arguments[0]\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      var scrollableParent = findScrollableParent(this);\n      var parentRects = scrollableParent.getBoundingClientRect();\n      var clientRects = this.getBoundingClientRect();\n\n      if (scrollableParent !== d.body) {\n        // reveal element inside parent\n        smoothScroll.call(\n          this,\n          scrollableParent,\n          scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n          scrollableParent.scrollTop + clientRects.top - parentRects.top\n        );\n\n        // reveal parent in viewport unless is fixed\n        if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n          w.scrollBy({\n            left: parentRects.left,\n            top: parentRects.top,\n            behavior: 'smooth'\n          });\n        }\n      } else {\n        // reveal element in viewport\n        w.scrollBy({\n          left: clientRects.left,\n          top: clientRects.top,\n          behavior: 'smooth'\n        });\n      }\n    };\n  }\n\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    // commonjs\n    module.exports = { polyfill: polyfill };\n  } else {\n    // global\n    polyfill();\n  }\n\n}());\n", "var candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n];\nvar candidateSelector = candidateSelectors.join(',');\n\nvar matches = typeof Element === 'undefined'\n  ? function () {}\n  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  var regularTabbables = [];\n  var orderedTabbables = [];\n\n  var candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var i, candidate, candidateTabindex;\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n\n    if (!isNodeMatchingSelectorTabbable(candidate)) continue;\n\n    candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map(function(a) { return a.node })\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\ntabbable.isTabbable = isTabbable;\ntabbable.isFocusable = isFocusable;\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (\n    !isNodeMatchingSelectorFocusable(node)\n    || isNonTabbableRadio(node)\n    || getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, candidateSelector) === false) return false;\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (\n    node.disabled\n    || isHiddenInput(node)\n    || isHidden(node)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nvar focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\nfunction isFocusable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, focusableCandidateSelector) === false) return false;\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr;\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) return true;\n  // This won't account for the edge case where you have radio groups with the same\n  // in separate forms on the same page.\n  var radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';\n}\n\nmodule.exports = tabbable;\n", "var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n", "/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n", "var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n", "var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n", "var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n", "/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n", "var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n", "var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n", "var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n", "/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n", "function polyfill(window) {\n  var ElementPrototype = window.Element.prototype;\n\n  if (typeof ElementPrototype.matches !== 'function') {\n    ElementPrototype.matches = ElementPrototype.msMatchesSelector || ElementPrototype.mozMatchesSelector || ElementPrototype.webkitMatchesSelector || function matches(selector) {\n      var element = this;\n      var elements = (element.document || element.ownerDocument).querySelectorAll(selector);\n      var index = 0;\n\n      while (elements[index] && elements[index] !== element) {\n        ++index;\n      }\n\n      return Boolean(elements[index]);\n    };\n  }\n\n  if (typeof ElementPrototype.closest !== 'function') {\n    ElementPrototype.closest = function closest(selector) {\n      var element = this;\n\n      while (element && element.nodeType === 1) {\n        if (element.matches(selector)) {\n          return element;\n        }\n\n        element = element.parentNode;\n      }\n\n      return null;\n    };\n  }\n}\n\nexport default polyfill;\n//# sourceMappingURL=index.mjs.map\n", "/**\n * Convert a value to an array.\n * @param  {mixed}   val\n * @return {Array}\n */\nexport default function toArray(val) {\n  return Array.prototype.slice.call(val);\n}\n", "import toArray from './toArray';\n\n/**\n * QSA = \"Query Selector All\" that returns an Array instead of a NodeList.\n * @param  {String}   selector\n * @param  {Element}  context\n * @return {Array}\n */\nexport default function qsa(selector, context) {\n  return selector ? toArray((context || document).querySelectorAll(selector)) : [];\n}\n", "import qsa from './qsa';\n\n/**\n * Get an array of elements from a mixed-value parameter.\n * Accepts Strings, Elements, and Array-like values.\n * @param  {String|Element|Array}  elements\n * @param  {Element}  context\n * @return {Array}\n */\nexport default function getElements(elements, context) {\n  // 1. If value is a String, query the DOM\n  if (typeof elements === 'string') {\n    return qsa(elements, context);\n  }\n\n  // 2. Put single element in an Array\n  if (elements instanceof Element) {\n    return [elements];\n  }\n\n  // 3. Assume everything can be treated like an Array\n  if (elements) {\n    return Array.prototype.slice.call(elements);\n  }\n\n  // 4. Otherwise, fallback to an empty array\n  return [];\n}\n", "/**\n * Check whether an object actually has a property.\n * @param  {Object} obj\n * @param  {String} prop\n * @return {Boolean}\n */\nexport default function hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n", "/**\n * Strict check for Objects. Literally checks whether\n * the value's constructor is \"Object\".\n * @param  {mixed}  val\n * @return {String}\n */\nexport default function isObject(val) {\n  return val && val.constructor.name === 'Object';\n}\n", "/**\n * Keep a value within some minimum and maximum values.\n * @param  {Number}  value\n * @param  {Number}  min\n * @param  {Number}  max\n * @return {Number}\n */\nexport default function minmax(value, min, max) {\n  value = Math.min(max, value);\n  value = Math.max(min, value);\n  return value;\n}\n", "/* eslint-disable getter-return */\n\n/**\n * Passive Event Listeners.\n *\n * Pass this value as a 3rd argument to your event listeners\n * to dramatically improve performance.\n *\n * @see https://developers.google.com/web/updates/2016/06/passive-event-listeners\n * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n * @type {Boolean}\n */\nconst passive = (() => {\n  let result = false;\n\n  try {\n    const opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        result = { passive: true };\n      },\n    });\n    window.addEventListener('testPassive', null, opts);\n    window.removeEventListener('testPassive', null, opts);\n  } catch (error) {\n    // 🤫\n  }\n\n  return result;\n})();\n\nexport default passive;\n", "/**\n * Pick keys from an object.\n * @param  {Object} obj\n * @param  {Array}  keys\n * @return {Object}\n */\nexport default function pick(obj, keys) {\n  return keys.reduce((result, key) => {\n    result[key] = obj[key];\n\n    return result;\n  }, {});\n}\n", "/* eslint-disable no-restricted-syntax, no-var, vars-on-top */\n\nimport hasOwnProperty from './hasOwnProperty';\n\n/**\n * Helper that does the same thing as `Object.values()`. Works in IE!\n * @param  {Object}  obj\n * @return {Array}\n */\nfunction values(obj) {\n  var arr = [];\n\n  for (var prop in obj) {\n    if (hasOwnProperty(obj, prop)) {\n      arr.push(obj[prop]);\n    }\n  }\n\n  return arr;\n}\n\n// Use native code if supported, else return polyfill.\n// eslint-disable-next-line no-confusing-arrow\nconst fn = (() => typeof Object.values === 'function' ? Object.values : values)();\n\nexport default fn;\n", "// Dependencies\nimport elementClosest from 'element-closest';\nimport smoothscroll from 'smoothscroll-polyfill';\nimport tabbable from 'tabbable';\n\n// Helpers\nimport debounce from 'lodash/debounce';\nimport throttle from 'lodash/throttle';\nimport getClosestAttribute from './helpers/getClosestAttribute';\nimport getElements from './helpers/getElements';\nimport getStyle from './helpers/getStyle';\nimport hasOwnProperty from './helpers/hasOwnProperty';\nimport isObject from './helpers/isObject';\nimport minmax from './helpers/minmax';\nimport on from './helpers/on';\nimport onReady from './helpers/onReady';\nimport passive from './helpers/passive';\nimport pick from './helpers/pick';\nimport qsa from './helpers/qsa';\nimport toArray from './helpers/toArray';\nimport values from './helpers/values';\n\n// Modules\nconst logger = (process.env.NODE_ENV !== 'production')\n  ? require('./modules/logger')\n  : {};\n\n// Internal Variables\nlet counter = 1;\n\n/**\n * Snap Slider.\n * @class\n */\nclass SnapSlider {\n  /**\n   * New Snap Slider.\n   *\n   * See `init()` for a full breakdown of `options`.\n   *\n   * @param  {String|Element|Array|Object}  containerOrOptions\n   * @param  {Object}                       options\n   * @constructor\n   */\n  constructor(containerOrOptions, options = {}) {\n    // Setup internal variables.\n    this.terms = {\n      prev: /(prev|back|before|left|up)/,\n      next: /(next|forward|after|right|down)/,\n    };\n\n    /* eslint-disable quote-props */\n    this.callbacks = {\n      'load': [],\n      'change': [],\n      'change.click': [],\n      'change.scroll': [],\n      'change.keydown': [],\n      'change.focusin': [],\n      'scroll': [],\n      'scroll.start': [],\n      'scroll.end': [],\n    };\n    /* eslint-enable quote-props */\n\n    this.init(containerOrOptions, options);\n\n    // Don't construct sliders with empty containers.\n    if (!this.container) {\n      return;\n    }\n\n    this.watchForChanges();\n\n    // Keep track of the slider so we can reference & debug it later.\n    this.container.SnapSlider = this;\n    window._SnapSliders[this.id] = this;\n  }\n\n  /**\n   * Initialize this slider.\n   *\n   * @param  {String|Element|Array|Object}  containerOrOptions\n   * @param  {Object}                       options\n   * @param  {String|Element|Array}         options.container\n   * @param  {String}                       options.id\n   * @param  {String|Element|Array}         options.slides\n   * @param  {String|Number}                options.start\n   * @param  {String|Element|Array}         options.nav\n   * @param  {String|Element|Array}         options.buttons\n   * @param  {String|Element|Array}         options.prev\n   * @param  {String|Element|Array}         options.next\n   * @return {void}\n   */\n  init(containerOrOptions, options = {}) {\n    // Allow people to quickly spin up sliders by just passing a container\n    // element, or by passing in a single options object.\n    if (isObject(containerOrOptions)) {\n      options = containerOrOptions;\n    }\n\n    // Fill default options.\n    this.options = {\n      container: containerOrOptions,\n      id: '',\n      slides: '',\n      nav: '',\n      buttons: '',\n      prev: '',\n      next: '',\n      start: 0,\n      loop: null,\n      on: {},\n      ...options,\n    };\n\n    // Get single element from params.\n    const container = getElements(this.options.container).shift();\n\n    // Don't construct sliders with empty containers.\n    if (!container) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.log(`\n🚫 Whoops! Snap Slider can't find a container element matching \"${this.options.container}\".\\n\n🔍 Please check your selectors for typos. Make sure the element actually exists\n   in the DOM when Snap Slider tries to initialize it.\\n\n👇 Here's a copy of the options you tried to initialize with for debugging:\\n\\n`, this.options, '\\n\\n');\n      }\n      return;\n    }\n\n    // Great! Now let's start initializing everything.\n    this.container = container;\n\n    // Get selectors from JavaScript or data attributes.\n    this.options.buttons = options.buttons || this.container.getAttribute('data-snap-slider-buttons');\n    this.options.prev = options.prev || this.container.getAttribute('data-snap-slider-prev');\n    this.options.next = options.next || this.container.getAttribute('data-snap-slider-next');\n\n    // Get and set persistent options in data attributes.\n    this.id = this.getMaybeSetID(container, this.options.id);\n    this.slides = this.getMaybeSetSlides(container, this.options.slides);\n    this.align = this.getMaybeSetAlign(container, this.options.align);\n    this.current = this.getMaybeSetStart(container, this.options.start);\n    this.loop = this.getMaybeSetLoop(container, this.options.loop);\n\n    // Reset internal variables.\n    this.transition = null;\n    this.scrolling = false;\n\n    // Add custom callbacks.\n    // eslint-disable-next-line no-restricted-syntax\n    for (const eventName in this.options.on) {\n      if (hasOwnProperty(this.options.on, eventName)) {\n        this.on(eventName, this.options.on[eventName]);\n      }\n    }\n\n    // Setup navigation.\n    // NOTE: If left blank, `addNav()` will handle the fallbacks for button selectors.\n    const navOptions = pick(this.options, [\n      'buttons',\n      'prev',\n      'next',\n    ]);\n\n    // Init custom goto buttons in the container.\n    // NOTE: \"Goto\" buttons are automatically handled by delegated click\n    // events on the `body`. For more details, see `handleGotoClick()`.\n    this.addGotoButtons({ ...navOptions, container });\n\n    // Init standard navs with data attributes.\n    this.addNav(`[data-snap-slider-nav=\"${this.id}\"]`, navOptions);\n\n    // Then init custom navs too.\n    if (this.options.nav) {\n      this.addNav(this.options.nav, navOptions);\n    }\n\n    // Go to the slide we want to start on.\n    this.update();\n  }\n\n  /**\n   * Get and maybe set a slider's ID on the closest container element.\n   *\n   * If no ID was specified, generates a fallback ID.\n   *\n   * @param  {Element}  container\n   * @param  {String}   id\n   * @return {String}\n   */\n  getMaybeSetID(container, id) {\n    // Either use the ID we were given or the ID already on the container.\n    id = id\n      || container.getAttribute('data-snap-slider')\n      || container.id;\n\n    // If we don't have an ID, make one up and increment our internal\n    // counter for the next slider.\n    if (!id) {\n      id = `slider-${counter}`;\n      counter += 1;\n    }\n\n    // Store value in data attribute.\n    container.setAttribute('data-snap-slider', id);\n\n    // Return the final ID.\n    return id;\n  }\n\n  /**\n   * Get all slide elements for a given container.\n   *\n   * Defaults to container's children.\n   *\n   * @param  {Element}  container\n   * @param  {String}   selector\n   * @return {Array}\n   */\n  getMaybeSetSlides(container, selector) {\n    // Get selector from JavaScript or data attribute.\n    selector = selector && typeof selector === 'string'\n      ? selector\n      : container.getAttribute('data-snap-slider-slides');\n\n    // Store value in data attribute.\n    container.setAttribute('data-snap-slider-slides', selector || '');\n\n    // If selector exists, use those elements. Otherwise,\n    // assume the container's immediate children are slides.\n    const slides = selector\n      ? getElements(selector, container)\n      : toArray(container.children);\n\n    // Ensure all slides are focusable but not tabbable.\n    slides.forEach((slide) => slide.setAttribute('tabindex', '-1'));\n\n    // Return array of slides.\n    return slides;\n  }\n\n  /**\n   * Get alignment fallback for a given container.\n   *\n   * @param  {Element}  container\n   * @param  {String}   align\n   * @return {String}\n   */\n  getMaybeSetAlign(container, align) {\n    // Get align index from JavaScript, data attribute, or leave blank.\n    align = align || container.getAttribute('data-snap-slider-align') || '';\n\n    // Store value in data attribute.\n    container.setAttribute('data-snap-slider-align', align);\n\n    return align;\n  }\n\n  /**\n   * Get start index for a given container.\n   *\n   * Defaults to 1.\n   *\n   * @param  {Element}  container\n   * @param  {String}   start\n   * @return {String|Number}\n   */\n  getMaybeSetStart(container, start) {\n    // Get start index from JavaScript, data attribute, or default to 1.\n    if (!SnapSlider.isValidIndex(start)) {\n      start = container.getAttribute('data-snap-slider-start') || 1;\n    }\n\n    // Store value in data attribute.\n    container.setAttribute('data-snap-slider-start', start);\n\n    return start;\n  }\n\n  /**\n   * Get and maybe set a slider's `loop` option on the closest container element.\n   *\n   * @param  {Element}  container\n   * @param  {Boolean}  loop\n   * @return {String}\n   */\n  getMaybeSetLoop(container, loop) {\n    // If we were given a Boolean value to set, use that.\n    // Else check for an existing data attribute.\n    // Defaults to `false`.\n    loop = typeof loop === 'boolean'\n      ? loop\n      : container.getAttribute('data-snap-slider-loop') === 'true';\n\n    // Store value in data attribute.\n    container.setAttribute('data-snap-slider-loop', loop);\n\n    // Return the final loop value.\n    return loop;\n  }\n\n  /**\n   * Get the `scroll-snap-align` for a snap slider element.\n   *\n   * Falls back to `data-snap-slider-align` when no CSS\n   * is detected, otherwise defaults to `start`.\n   *\n   * @param  {Element}  el\n   * @return {String}\n   */\n  getSnapAlign(el) {\n    // Get element's CSS align value.\n    const style = getStyle(el, 'scrollSnapAlign');\n\n    // If browser supports Scroll Snap and slide\n    // has a non-empty value, return it.\n    if (style && style.indexOf('none') < 0) {\n      return style;\n    }\n\n    // Otherwise, fallback to the slider's align attribute.\n    // Else assume \"start\" for everything.\n    return getClosestAttribute(el, 'data-snap-slider-align')\n      || 'start';\n  }\n\n  /**\n   * Get a specific slide element. Accepts any valid goto alias.\n   *\n   * @param  {Number}   index  Starts at 1.\n   * @return {Element}\n   */\n  getSlide(index) {\n    // Convert index aliases to numbers.\n    index = this.getIndexNumber(index);\n\n    // Return the slide for that numeric index.\n    // NOTE: Subtract 1 because the array is 0-index, but our API is 1-index.\n    return this.slides[index - 1];\n  }\n\n  /**\n   * Get the current slide element.\n   *\n   * @return {Element}\n   */\n  getCurrentSlide() {\n    // NOTE: Subtract 1 because the array is 0-index, but our API is 1-index.\n    return this.slides[this.current - 1];\n  }\n\n  /**\n   * Is this a valid index?\n   *\n   * - first\n   * - middle\n   * - last\n   * - prev\n   * - next\n   *\n   * @param  {String|Number}  index\n   * @return {Number}\n   */\n  static isValidIndex(index) {\n    const aliases = [\n      'first',\n      'middle',\n      'last',\n      'prev',\n      'next',\n    ];\n\n    // Valid indexes are either a known alias,\n    // or a positive integer.\n    return aliases.indexOf(index) >= 0\n      || parseInt(index, 10) >= 1;\n  }\n\n  /**\n   * Get the slide number for any index.\n   *\n   * Returns -1 if index is invalid.\n   *\n   * @param  {String|Number}  index\n   * @return {Number}\n   */\n  getIndexNumber(index) {\n    let num;\n\n    if (index === 'first') {\n      // Get the first slide.\n      num = 1;\n    } else if (index === 'middle') {\n      // Get the middle slide.\n      num = Math.ceil(this.slides.length / 2);\n    } else if (index === 'last') {\n      // Get the last slide.\n      num = this.slides.length;\n    } else if (index === 'prev') {\n      // Get the previous slide.\n      num = this.current - 1;\n    } else if (index === 'next') {\n      // Get the next slide.\n      num = this.current + 1;\n    } else {\n      // Try to get a number.\n      num = parseInt(index, 10) || -1;\n    }\n\n    if (this.loop) {\n      // If we're looping, send out-of-bounds requests\n      // to the other end of the slider.\n      if (num < 1) {\n        num = this.slides.length;\n      }\n\n      if (num > this.slides.length) {\n        num = 1;\n      }\n    } else if (num < 1 || num > this.slides.length) {\n      // Otherwise, ignore out-of-range indexes.\n      num = -1;\n    }\n\n    // Return numeric index. Or, if something goes wrong,\n    // fallback to the first slide.\n    return num || 1;\n  }\n\n  /**\n   * Get the offset we should scroll to for a specific slide.\n   *\n   * @param  {Element}  slide\n   * @return {Object}   { top, left }\n   */\n  getScrollOffset(slide) {\n    const { container } = this;\n    const align = this.getSnapAlign(slide);\n\n    // Calculate the 'start' position by default.\n    // NOTE: This forces slides with align `none` to still snap into place.\n    let top = slide.offsetTop;\n    let left = slide.offsetLeft;\n\n    // NOTE: Because Safari uses the 2-value syntax, we simply check for matching\n    // keywords. If this causes incorrect behavior, use the `data-snap-slider-align`\n    // attribute to override our automatic CSS detection.\n    if (align.indexOf('center') >= 0) {\n      // To center a slide, start with its beginning offset (the 'start' position).\n      // Then add half the slide's size minus half the container size.\n      top = slide.offsetTop + slide.offsetHeight / 2 - container.offsetHeight / 2;\n      left = slide.offsetLeft + slide.offsetWidth / 2 - container.offsetWidth / 2;\n    } else if (align.indexOf('end') >= 0) {\n      // To align the end of a slide, start with its beginning offset (the 'start' position).\n      // Then subtract the size of the container, but add back the size of the slide.\n      top = slide.offsetTop - container.offsetHeight + slide.offsetHeight;\n      left = slide.offsetLeft - container.offsetWidth + slide.offsetWidth;\n    }\n\n    // Keep offsets within the scrollable area.\n    top = minmax(top, 0, container.scrollHeight);\n    left = minmax(left, 0, container.scrollWidth);\n\n    return { top, left };\n  }\n\n  /**\n   * Go to a slide.\n   *\n   * @param  {String|Number}  index                    Starts at 1.\n   * @param  {Object}         options\n   * @param  {Boolean}        options.focus\n   * @param  {Boolean}        options.force\n   * @param  {Boolean}        options.ignoreCallbacks\n   * @param  {Boolean}        options.immediate\n   * @param  {Event}          event\n   * @return {Boolean}\n   */\n  goto(index, options = {}, event) {\n    // Fill default options.\n    options = {\n      // By default, focus the slide we're going to.\n      focus: true,\n      // Force-update the scroll position, even if we're already on the current slide.\n      force: false,\n      // Ignore custom callbacks for events.\n      ignoreCallbacks: false,\n      // Immediately update position without smooth scrolling.\n      immediate: false,\n      ...options,\n    };\n\n    // Get the next slide we should go to.\n    const next = this.getIndexNumber(index);\n\n    // If nothing changed, don't do anything (as long as\n    // we're not trying to force it).\n    if (!options.force && next === this.current) {\n      return false;\n    }\n\n    // Get the next slide.\n    const slide = this.getSlide(next);\n\n    if (!slide) {\n      return false;\n    }\n\n    // Scroll to it!\n    const { top, left } = this.getScrollOffset(slide);\n\n    if (options.immediate) {\n      // Scroll immediately.\n      this.container.scroll({ top, left });\n    } else {\n      // Let the event handlers know we're coming, then smooth scroll.\n      this.startTransition(next);\n      this.container.scroll({ top, left, behavior: 'smooth' });\n    }\n\n    // Update state.\n    this.current = next;\n\n    // We changed slides!\n    this.fireEvent('change', event, options);\n\n    return true;\n  }\n\n  /**\n   * Build the `goto` attribute for a nav button.\n   *\n   * @param  {Element|Boolean}  nav\n   * @param  {String|Number}    index\n   * @return {String}\n   */\n  buildGoto(nav, index = '') {\n    // Start with an empty string.\n    let goto = '';\n\n    // If this button isn't part of a nav, include the slider ID.\n    if (!nav) {\n      goto += `${this.id}:`;\n    }\n\n    // Add the index and return.\n    return goto + index;\n  }\n\n  /**\n   * Set the `goto` attribute for nav buttons.\n   *\n   * @param  {String|Element|Array}  buttons\n   * @param  {String}                index\n   * @return {void}\n   */\n  setGoto(buttons, index) {\n    buttons = getElements(buttons);\n\n    // If we found custom prev/next buttons, set their `goto` attributes\n    // before we loop through the rest of the buttons.\n    buttons.forEach((button) => {\n      button.setAttribute('data-snap-slider-goto', this.buildGoto(\n        // Don't assume this button is grouped with the others. It may\n        // be somewhere else on the page, so double check for a parent\n        // slider or nav container.\n        button.closest('[data-snap-slider], [data-snap-slider-nav]'),\n        index,\n      ));\n    });\n  }\n\n  /**\n   * Get the slider ID and slide index a goto button is targeting.\n   *\n   * NOTE: This method is static so we can call it in the delegated body\n   * click events. For more details, see `handleGotoClick()`.\n   *\n   * @param  {String|Element|Array}  button\n   * @return {Object}                { sliderID, index }\n   */\n  static getButtonTarget(button) {\n    // Where are we going?\n    const goto = button ? button.getAttribute('data-snap-slider-goto') : '';\n\n    // Ignore missing buttons and attributes.\n    if (!goto) {\n      return {};\n    }\n\n    // Parse slide index and slider ID from `goto` attribute.\n    const args = goto.split(':').map((str) => str.trim());\n    const index = args.pop();\n    let sliderID = args.pop();\n\n    // If the slider ID wasn't included, check for a parent nav or container element.\n    if (!sliderID) {\n      const nav = button.closest('[data-snap-slider-nav]');\n      const container = button.closest('[data-snap-slider]');\n\n      // If it is in a nav or container, get the slider ID from there.\n      if (nav) {\n        sliderID = nav.getAttribute('data-snap-slider-nav');\n      }\n\n      if (container) {\n        sliderID = container.getAttribute('data-snap-slider');\n      }\n    }\n\n    // If there's still no slider ID, is this button already in a slider?\n    if (!sliderID) {\n      const slider = button.closest('data-snap-slider');\n\n      // If it is in a slider, get the slider ID from there.\n      if (slider) {\n        sliderID = slider.getAttribute('data-snap-slider');\n      }\n    }\n\n    return { sliderID, index };\n  }\n\n  /**\n   * Handle click events for nav (aka \"goto\") buttons.\n   *\n   * By delegating events to the body, we can automatically\n   * handle dynamic goto buttons (i.e., without having to\n   * reinitialize slider events).\n   *\n   * @param  {Event}  event\n   * @return {void}\n   */\n  static handleGoto(event) {\n    // Get the button we clicked.\n    const button = event.target.closest('[data-snap-slider-goto]');\n\n    // Get the slider we're trying to update.\n    const { sliderID, index } = SnapSlider.getButtonTarget(button);\n    const slider = window._SnapSliders[sliderID];\n\n    // Make sure it actually exists.\n    if (!slider) {\n      return;\n    }\n\n    // Go! But only focus the slide if we're NOT clicking a prev/next button.\n    slider.goto(index, null, event);\n  }\n\n  /**\n   * Start transitioning to another slide.\n   *\n   * This way when you click a nav button, the current slide updates\n   * immediately but the scroll listener doesn't override it, or fire\n   * extra change events.\n   *\n   * @param  {Number}  next\n   * @return {void}\n   */\n  startTransition(next) {\n    // Tell the scroll listener which slide we're transitioning to.\n    this.transition = {\n      from: this.current,\n      to: next,\n      diff: Math.abs(next - this.current),\n    };\n\n    // In case someone's fast enough to start scrolling again before our\n    // scroll listener resolves the `transition` flag, or if the slide's\n    // already visible and nothing actually has to scroll,\n    // set a timeout to resolve the transition.\n    const stuck = this.transition.to;\n\n    // If there's already a check waiting, clear it to avoid accidentally\n    // reverting to the wrong slide.\n    if (this.checkTransition) {\n      clearTimeout(this.checkTransition);\n    }\n\n    // Now make sure we don't get stuck!\n    this.checkTransition = setTimeout(() => {\n      if (this.transition.to === stuck) {\n        this.stopTransition();\n      }\n    }, 1000);\n  }\n\n  /**\n   * Stop the transitions! Set things back to normal.\n   *\n   * @return {void}\n   */\n  stopTransition() {\n    // Clear transition checks.\n    this.transition = null;\n    clearTimeout(this.checkTransition);\n  }\n\n  /**\n   * Is this a \"previous\" button?\n   *\n   * @param  {String|Element|Array}  button\n   * @return {Boolean}\n   */\n  isPrevButton(button) {\n    button = getElements(button).shift();\n\n    // Ignore missing elements.\n    if (!button) {\n      return false;\n    }\n\n    // Check whether the `goto` attribute is \"prev\".\n    // If not, check the text & class for common \"prev\" terms.\n    return (button.getAttribute('data-snap-slider-goto') || '').match(/\\bprev$/)\n      || button.textContent.toLowerCase().match(this.terms.prev)\n      || button.className.toLowerCase().match(this.terms.prev);\n  }\n\n  /**\n   * Is this a \"next\" button?\n   *\n   * @param  {String|Element|Array}  button\n   * @return {Boolean}\n   */\n  isNextButton(button) {\n    button = getElements(button).shift();\n\n    // Ignore missing elements.\n    if (!button) {\n      return false;\n    }\n\n    // Check whether the `goto` attribute is \"next\".\n    // If not, check the text & class for common \"next\" terms.\n    return (button.getAttribute('data-snap-slider-goto') || '').match(/\\bnext$/)\n      || button.textContent.toLowerCase().match(this.terms.next)\n      || button.className.toLowerCase().match(this.terms.next);\n  }\n\n  /**\n   * Is this index a relative term? I.e., is it `prev` or `next`?\n   *\n   * @param  {String|Number}  index\n   * @return {Boolean}\n   */\n  static isRelative(index) {\n    return index === 'prev' || index === 'next';\n  }\n\n  /**\n   * Does an index match the current slide?\n   *\n   * @param  {String|Number}  index\n   * @return {Boolean}\n   */\n  isCurrent(index) {\n    // Ignore relative indexes (i.e., `prev` and `next`) since they\n    // always refer to one more or less than the current index.\n    if (SnapSlider.isRelative(index)) {\n      return false;\n    }\n\n    // Does this numeric index match the current slide?\n    return this.getIndexNumber(index) === this.current;\n  }\n\n  /**\n   * Add goto buttons for the current slider.\n   *\n   * @param  {String|Element|Array|Object}  buttonsOrOptions\n   * @param  {Object}                       options\n   * @param  {String|Element|Array}         options.container\n   * @param  {String|Element|Array}         options.buttons\n   * @param  {String|Element|Array}         options.prev\n   * @param  {String|Element|Array}         options.next\n   * @return {Boolean}\n   */\n  addGotoButtons(buttonsOrOptions, options = {}) {\n    // Allow people to quickly add nav buttons by just passing the\n    // selector, or by passing in a single options object.\n    if (isObject(buttonsOrOptions)) {\n      options = buttonsOrOptions;\n    }\n\n    // Fill default options.\n    options = {\n      container: '',\n      buttons: buttonsOrOptions,\n      prev: '',\n      next: '',\n      ...options,\n    };\n\n    // Get button elements.\n    // NOTE: If someone passes an overly-generic selector (e.g., `button`)\n    // this will query the entire document. In general, you should either\n    // specify a container element, use specific selectors, or pass\n    // the elements directly.\n    const buttons = getElements(options.buttons, options.container);\n    const prev = getElements(options.prev, options.container);\n    const next = getElements(options.next, options.container);\n\n    // If we found custom prev/next buttons, set their `goto` attributes\n    // before we loop through the rest of the buttons.\n    prev.forEach((b) => b.hasAttribute('data-snap-slider-goto') || this.setGoto(prev, 'prev'));\n    next.forEach((b) => b.hasAttribute('data-snap-slider-goto') || this.setGoto(next, 'next'));\n\n    // Keep track of the index outside of the loop so we can\n    // skip prev/next buttons but still go in order.\n    let nextIndex = 1;\n\n    // Loop through the buttons and set each one's `goto` attribute.\n    buttons.forEach((button) => {\n      // Ignore buttons that already have a `goto` attribute.\n      if (button.hasAttribute('data-snap-slider-goto')) {\n        return null;\n      }\n\n      // Previous\n      if (this.isPrevButton(button)) {\n        return this.setGoto(button, 'prev');\n      }\n\n      // Next\n      if (this.isNextButton(button)) {\n        return this.setGoto(button, 'next');\n      }\n\n      // Numeric: Check the text for a number, else fallback to the next index.\n      const index = parseInt(button.textContent.replace(/.*\\b(\\d+)\\b.*/, '$1'), 10) || nextIndex;\n\n      // Increment the next index.\n      nextIndex = index + 1;\n\n      return this.setGoto(button, index);\n    });\n\n    this.updateButtons();\n\n    return true;\n  }\n\n  /**\n   * Get navs for the current slider.\n   *\n   * @return {Array}\n   */\n  getNavs() {\n    // eslint-disable-next-line arrow-body-style\n    return qsa('[data-snap-slider-nav]').filter((nav) => {\n      // Only return navs targeting the current slider.\n      return nav.getAttribute('data-snap-slider-nav') === this.id;\n    });\n  }\n\n  /**\n   * Get nav buttons for the current slider.\n   *\n   * @return {Array}\n   */\n  getButtons() {\n    return qsa('[data-snap-slider-goto]').filter((button) => {\n      const { sliderID } = SnapSlider.getButtonTarget(button);\n      // Only return buttons targeting the current slider.\n      return sliderID === this.id;\n    });\n  }\n\n  /**\n   * Update nav buttons for the current slider.\n   *\n   * @return {void}\n   */\n  updateButtons() {\n    // Wait until the slider has initialized.\n    if (!this.current) {\n      return;\n    }\n\n    // Loop through all the nav buttons.\n    this.getButtons().forEach((button) => {\n      // Figure out which slide it's for...\n      const { index } = SnapSlider.getButtonTarget(button);\n\n      // And update its class.\n      if (this.isCurrent(index)) {\n        button.classList.add('is-current');\n      } else {\n        button.classList.remove('is-current');\n      }\n\n      // Also, enable/disable relative buttons unless `loop` is on.\n      if (!this.loop && SnapSlider.isRelative(index)) {\n        // Disable prev button on first slide.\n        // Disable next button on last slide.\n        const disabled = (index === 'prev' && this.current === 1)\n          || (index === 'next' && this.current === this.slides.length);\n\n        if (disabled) {\n          // button.setAttribute('disabled', '');\n          button.classList.add('is-disabled');\n        } else {\n          // button.removeAttribute('disabled', '');\n          button.classList.remove('is-disabled');\n        }\n      }\n    });\n  }\n\n  /**\n   * Update slide active states when the slider changes.\n   *\n   * @return {void}\n   */\n  updateSlides() {\n    this.slides.forEach((slide, index) => {\n      // NOTE: Subtract 1 because the array is 0-index, but our API is 1-index.\n      if (index === this.current - 1) {\n        slide.classList.add('is-current');\n        slide.removeAttribute('aria-hidden');\n\n        // Enable tabbing for current slide\n        qsa('[data-snap-slider-tabindex]', slide).forEach((tab) => {\n          tab.removeAttribute('tabindex');\n        });\n      } else {\n        slide.classList.remove('is-current');\n        slide.setAttribute('aria-hidden', 'true');\n\n        // Disable tabbing for non-current slides\n        tabbable(slide).forEach((tab) => {\n          tab.setAttribute('tabindex', '-1');\n          tab.setAttribute('data-snap-slider-tabindex', '');\n        });\n      }\n    });\n  }\n\n  /**\n   * Add a nav element for the current slider. Automatically hooks up any nav\n   * buttons inside the nav.\n   *\n   * @param  {String|Element|Array|Object}  containerOrOptions\n   * @param  {Object}                       options\n   * @param  {String|Element|Array}         options.container\n   * @param  {String|Element|Array}         options.buttons\n   * @param  {String|Element|Array}         options.prev\n   * @param  {String|Element|Array}         options.next\n   * @return {Boolean}\n   */\n  addNav(containerOrOptions, options = {}) {\n    // Allow people to quickly add a nav by just passing a container\n    // element, or by passing in a single options object.\n    if (isObject(containerOrOptions)) {\n      options = containerOrOptions;\n    }\n\n    // Fill default options.\n    options = {\n      container: containerOrOptions,\n      buttons: '',\n      prev: '',\n      next: '',\n      ...options,\n    };\n\n    // Get matching nav containers.\n    const navContainers = getElements(options.container);\n\n    // Don't add navs without container elements.\n    if (!navContainers.length) {\n      return false;\n    }\n\n    navContainers.forEach((navContainer) => {\n      // Set a data attribute assigning the nav to this slider.\n      navContainer.setAttribute('data-snap-slider-nav', this.id);\n\n      // Get button selectors from JavaScript, data attribute, or default to 'button'.\n      // NOTE: In this case, allow the nav's data attribute to override the parent\n      // container's options.\n      const buttons = navContainer.getAttribute('data-snap-slider-buttons')\n        || options.buttons\n        || 'button';\n      const prev = options.prev || navContainer.getAttribute('data-snap-slider-prev');\n      const next = options.next || navContainer.getAttribute('data-snap-slider-next');\n\n      // And add them.\n      this.addGotoButtons({\n        container: navContainer,\n        buttons,\n        prev,\n        next,\n      });\n    });\n\n    return true;\n  }\n\n  /**\n   * Which slide is closest to its active offset position?\n   *\n   * Returns an object include the slide's index, element,\n   * and the diff between its active offset and our\n   * current scroll position.\n   *\n   * @return {Object}  { index, slide, diff }\n   */\n  getClosest() {\n    return this.slides.reduce((prev, slide, index) => {\n      // 1-index to stay consistent with our API.\n      index += 1;\n\n      // How far away are we from the next slide's active offset position?\n      const offset = this.getScrollOffset(slide);\n      const diff = {\n        top: Math.abs(this.container.scrollTop - offset.top),\n        left: Math.abs(this.container.scrollLeft - offset.left),\n      };\n\n      // Save the next slide's info to compare with other slides.\n      const next = { index, slide, diff };\n\n      // If this is the first slide, return it and compare the next one.\n      if (!prev) {\n        return next;\n      }\n\n      // Compare each slide to see which one is the closest to its active offset position.\n      // As soon as the next slide is at least as close as the previous one, return it.\n      if (next.diff.left <= prev.diff.left && next.diff.top <= prev.diff.top) {\n        return next;\n      }\n\n      // Otherwise, keep the last closest slide.\n      return prev;\n    // Init with `false` so the first slide gets processed just like the rest of them.\n    }, false);\n  }\n\n  /**\n   * Watch the container scroll for when the current slide changes.\n   *\n   * @return {void}\n   */\n  watchForChanges() {\n    // Scroll listener. Save so we can remove it during `destroy()`.\n    this.scrollListener = throttle((event) => {\n      // Which slide is closest to their active offset position?\n      const closest = this.getClosest();\n\n      // If someone's passively scrolling (i.e., not in a transition),\n      // then  as soon as we've scrolled to another slide, mark that\n      // slide as the new current one and fire a change event.\n      if (!this.transition && closest.index !== this.current) {\n        this.current = closest.index;\n        this.fireEvent('change', event);\n      }\n\n      // If we just started scrolling, update state and\n      // fire a `scroll.start` event.\n      if (!this.scrolling) {\n        this.scrolling = true;\n        this.fireEvent('scroll.start', event);\n      }\n\n      // Fire a generic `scroll` event.\n      this.fireEvent('scroll', event);\n    }, 250);\n\n    // Scroll end listener. Save so we can remove it during `destroy()`.\n    this.scrollEndListener = debounce((event) => {\n      // We're done scrolling!\n      this.scrolling = false;\n      this.fireEvent('scroll.end', event);\n\n      // Clear any previous transition checks.\n      // NOTE: This has to happen *after* we fire the `scroll.end` event,\n      // otherwise `handleFocus` won't be able to access `this.transition`.\n      this.stopTransition();\n    }, 250);\n\n    // Arrow key listener. Save so we can remove it during `destroy()`.\n    this.arrowKeyListener = throttle((event) => {\n      // Ignore events that have already been prevented.\n      if (event.defaultPrevented) {\n        return;\n      }\n\n      // Listen for arrow keys.\n      // @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n      const isPrev = ['Up', 'ArrowUp', 'Left', 'ArrowLeft'].indexOf(event.key) >= 0;\n      const isNext = ['Down', 'ArrowDown', 'Right', 'ArrowRight'].indexOf(event.key) >= 0;\n\n      // Ignore non-arrow keys.\n      if (!isPrev && !isNext) {\n        return;\n      }\n\n      // Go to the next or previous slide.\n      this.goto(isNext ? 'next' : 'prev', null, event);\n\n      // Prevent default browser scroll.\n      event.preventDefault();\n    }, 250);\n\n    // Focus listener. Save so we can remove it during `destroy()`.\n    this.focusListener = (event) => {\n      // Only trigger `goto` on focus when we're not passively scrolling.\n      // However, if someone manually triggered a transition then\n      // allow them to click or tab away to a different slide.\n      if (this.scrolling && !this.transition) {\n        return;\n      }\n\n      // Get slide + index.\n      let slide;\n      let index;\n\n      this.slides.forEach((s, i) => {\n        if (s.contains(event.target)) {\n          slide = s;\n          index = i + 1;\n        }\n      }, null);\n\n      // If there's a matching slide, go to it.\n      if (slide) {\n        this.goto(index, null, event);\n      }\n    };\n\n    // Resize Observer. Save so we can disconnect it during `destroy()`.\n    // Only init if browser supports it, else fallback to noop.\n    this.resizeObserver = { observe: () => {}, disconnect: () => {} };\n    if ('ResizeObserver' in window) {\n      this.resizeObserver = new ResizeObserver(this.resizeCallback.bind(this));\n    }\n\n    // Add all our listeners.\n    // Set timeout to avoid initial `goto` event triggering a scroll listener.\n    setTimeout(() => {\n      this.container.addEventListener('scroll', this.scrollListener, passive);\n      this.container.addEventListener('scroll', this.scrollEndListener, passive);\n      this.container.addEventListener('keydown', this.arrowKeyListener);\n      this.container.addEventListener('focusin', this.focusListener);\n      this.resizeObserver.observe(this.container);\n\n      // Done loading!\n      this.fireEvent('load');\n    }, 100);\n  }\n\n  /**\n   * Update the slider on load.\n   *\n   * @return {void}\n   */\n  hasLoaded() {\n    this.container.classList.add('has-loaded');\n  }\n\n  /**\n   * Update this slider (e.g., on resize). Basically just repositions the\n   * current slide.\n   *\n   * @return {void}\n   */\n  update() {\n    // Make sure we're still on the current slide.\n    this.goto(this.current, {\n      focus: false,\n      force: true,\n      ignoreCallbacks: true,\n      immediate: true,\n    });\n  }\n\n  /**\n   * Destroy this slider. Stop any active transitions, remove its event\n   * listeners, and delete it from our internal array of slider instances.\n   *\n   * @return {void}\n   */\n  destroy() {\n    // Stop running transitions, event listeners, etc.\n    this.stopTransition();\n    this.container.removeEventListener('scroll', this.scrollListener);\n    this.container.removeEventListener('scroll', this.scrollEndListener);\n    this.container.removeEventListener('keydown', this.arrowKeyListener);\n    this.resizeObserver.disconnect();\n\n    // Reset callbacks.\n    // eslint-disable-next-line no-restricted-syntax\n    for (const eventName in this.callbacks) {\n      if (hasOwnProperty(this.callbacks, eventName)) {\n        this.callbacks[eventName] = [];\n      }\n    }\n\n    // Remove references to this slider.\n    delete this.container.SnapSlider;\n    delete window._SnapSliders[this.id];\n  }\n\n  /**\n   * Reset this slider (e.g., after adding or removing a slide).\n   *\n   * See `init()` for a full breakdown of `options`.\n   *\n   * @param  {Object}  options\n   * @return {void}\n   */\n  reset(options = {}) {\n    // Copy initial options.\n    const initialOptions = this.options;\n\n    // Remove initial callbacks to avoid duplicating them.\n    delete initialOptions.on;\n\n    // Don't let people reset critical options during reset (e.g., slider ID).\n    delete options.container;\n    delete options.id;\n\n    // Re-initialize this slider with initial options + overrides.\n    this.init(this.container, { ...initialOptions, ...options });\n  }\n\n  /**\n   * Handle resize observer events.\n   *\n   * @return {void}\n   */\n  resizeCallback() {\n    this.update();\n  }\n\n  /**\n   * When an event happens, fire all the callback functions for that event.\n   *\n   * @param  {String}   eventName\n   * @param  {Event}    event\n   * @param  {Object}   options\n   * @param  {Boolean}  options.focus\n   * @param  {Boolean}  options.ignoreCallbacks\n   * @return {void}\n   */\n  fireEvent(eventName, event, options = {}) {\n    // Ignore invalid events.\n    if (!hasOwnProperty(this.callbacks, eventName)) {\n      return;\n    }\n\n    // Fill default options.\n    options = {\n      // By default, focus the slide we're going to.\n      focus: true,\n      // Ignore custom callbacks for events.\n      ignoreCallbacks: false,\n      ...options,\n    };\n\n    // Required: Update slider attributes on load.\n    if (eventName === 'load') {\n      this.hasLoaded();\n    }\n\n    // Required: Update buttons and slides on every change.\n    if (eventName === 'change') {\n      this.updateButtons();\n      this.updateSlides();\n    }\n\n    // Allow focus events to be ignored.\n    if (options.focus) {\n      this.handleFocus(eventName, event);\n    }\n\n    // Allow callbacks to be ignored.\n    if (options.ignoreCallbacks) {\n      return;\n    }\n\n    // Fallback object for `null` events.\n    event = event || {};\n\n    // Include more granular event types for easier callbacks.\n    const events = [eventName];\n\n    if (hasOwnProperty(this.callbacks, `${eventName}.${event.type}`)) {\n      events.push(`${eventName}.${event.type}`);\n    }\n\n    // Fire all the callbacks for each event.\n    events.forEach((name) => {\n      this.callbacks[name].forEach((callback) => {\n        if (typeof callback === 'function') {\n          callback(this, event);\n        }\n      });\n    });\n  }\n\n  /**\n   * Handle focus events differently depending on whether we're manually\n   * triggering changes or passively scrolling.\n   *\n   * @param  {String}   eventName\n   * @param  {Event}    event\n   * @return {void}\n   */\n  handleFocus(eventName, event) {\n    // Only handle focus for manually triggered changes (e.g., clicks and key presses).\n    // Ignore passive scrolling to avoid mistakenly hijacking someone's focus.\n    if (!this.transition) {\n      return;\n    }\n\n    // Only focus the slide if we're NOT clicking a prev/next button.\n    if (event && eventName === 'change') {\n      // Did we click a button?\n      const button = event.target.closest('[data-snap-slider-goto]');\n      const { index } = SnapSlider.getButtonTarget(button);\n\n      // If we clicked a relative button, get out.\n      if (SnapSlider.isRelative(index)) {\n        return;\n      }\n    }\n\n    // If we're only transitioning one slide over, focus immediately on change.\n    if (this.transition.diff <= 1 && eventName === 'change') {\n      this.getCurrentSlide().focus({ preventScroll: true });\n    }\n\n    // If we're transitioning across multiple slides, wait until the scroll ends to focus.\n    // Otherwise, we'll cause the scroll to flicker.\n    if (this.transition.diff > 1 && eventName === 'scroll.end') {\n      // Only focus the slide if we haven't already focused on another\n      // element during the transition.\n      if (!document.activeElement\n        || document.activeElement === document.body\n        || document.activeElement.closest('[data-snap-slider-goto]')) {\n        this.getCurrentSlide().focus({ preventScroll: true });\n      }\n    }\n  }\n\n  /**\n   * Add callbacks to fire on specific events.\n   *\n   * @param  {String}    event     Event name.\n   * @param  {Function}  callback  Function w/ slider and event params (e.g., `fn(slider, event)`).\n   * @return {void}\n   */\n  on(event, callback) {\n    // Ignore invalid events.\n    if (!hasOwnProperty(this.callbacks, event)) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.log(`\n🚫 Whoops! Snap Slider can't add events for \"${event}\".\\n\n📝 Please make sure your event matches one of the ones in this list:\\n\\n`, Object.keys(this.callbacks), '\\n\\n');\n      }\n      return;\n    }\n\n    // Ignore invalid callbacks.\n    if (typeof callback !== 'function') {\n      if (process.env.NODE_ENV !== 'production') {\n        console.log(`\n  🚫 Whoops! Snap Slider can only add functions as callbacks.\\n\n  👀 It looks like you passed a \"${typeof callback}\" instead.\\n\\n`, callback, '\\n\\n');\n      }\n      return;\n    }\n\n    // Add the callback for our event.\n    this.callbacks[event].push(callback);\n  }\n\n  /**\n   * Log that we couldn't find the element you're looking for.\n   *\n   * @param  {mixed}  element\n   * @return {void}\n   */\n  static notFound(element) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(`\n😢 Oh no! Snap Slider couldn't find a slider for \"${element}\".\\n\n-------------------------------------------------------------------------------------------\nℹ️ NOTE: Make sure the elements you're trying to debug have a \\`data-snap-slider\\` attribute.\n-------------------------------------------------------------------------------------------\\n\\n`);\n    }\n  }\n\n  /**\n   * Get the `SnapSlider` object for a slider based on its ID.\n   *\n   * @param  {String}      id\n   * @return {SnapSlider}\n   */\n  static get(id) {\n    return window._SnapSliders[id];\n  }\n\n  /**\n   * `console.log` info about a slider, its nav, or goto buttons.\n   *\n   * @param  {String|Element|Array} idOrElements\n   * @return {void}\n   */\n  static debug(idOrElements) {\n    if (process.env.NODE_ENV !== 'production') {\n      /* eslint-disable no-irregular-whitespace */\n      let elements = [];\n\n      // 1. Debug all sliders by default.\n      if (arguments.length === 0) {\n        idOrElements = '[data-snap-slider]';\n      }\n\n      // 2. Debug a slider by its ID.\n      if (typeof idOrElements === 'string'\n        && hasOwnProperty(window._SnapSliders, idOrElements)) {\n        idOrElements = `[data-snap-slider=\"${idOrElements}\"]`;\n      }\n\n      // 3. Debug slider elements.\n      elements = getElements(idOrElements);\n\n      if (!elements.length) {\n        SnapSlider.notFound(idOrElements);\n        return;\n      }\n\n      // Debug all the things!\n      elements.forEach((el, i) => {\n        // What are we debugging? Is this a button, nav, or container?\n        const button = el.closest('[data-snap-slider-goto]');\n        const nav = el.closest('[data-snap-slider-nav]');\n        const container = el.closest('[data-snap-slider]');\n\n        // If we're debugging more than one element at a time,\n        // add the index # to each section heading.\n        const num = elements.length > 1 ? `#${i + 1} ` : '';\n\n        // 2a. Buttons\n        if (button) {\n          // Get details for the target slider & slide.\n          const target = SnapSlider.getButtonTarget(button);\n          const slider = window._SnapSliders[target.sliderID];\n\n          // Make sure slide index is valid.\n          const { index } = target;\n          const slideIndex = SnapSlider.isValidIndex(index)\n            ? `\"${index}\"`\n            : `🚫 \"${index}\" - Yikes! This index is invalid.\\n\\nUse a positive number instead, or one of the following aliases:\\n\n  ${['first', 'middle', 'last', 'prev', 'next'].map((a) => `• ${a}`).join('\\n')}`;\n\n          // \"We couldn't find anything.\"\n          const sliderID = target.sliderID\n            ? `\"${target.sliderID}\"`\n            : `🤷‍♀️ We couldn't find any.\\n\n  • Make sure your button is inside a \\`data-snap-slider-nav\\` element, or...\n  • Include the slider ID you want to target in your \\`data-snap-slider-goto\\` attribute.\n      ◦ For example, \\`data-snap-slider-goto=\"example-slider:${target.index || 'prev'}\"\\`.`;\n\n          let sliderContainer = `🤷‍♀️ We couldn't find any.\\n\n  • Double check that your slider ID is correct (👆).\n  • Make sure your slider has the same ID in its \\`data-snap-slider\\` attribute.\n      ◦ For example, \\`data-snap-slider=\"example-slider\"\\`.`;\n          let slideIndexNumber = `🤷‍♀️ We couldn't find any.\\n\n  • Double check that your index is valid (👆).\n  • Make sure a slide actually exists at that index (👇).`;\n          let slide = `🤷‍♀️ We couldn't find any.\\n\n  • Double check that your index is valid (👆).\n  • Make sure a slide actually exists at that index.\n  • Make sure your slider recognizes the slide element as a slide.`;\n\n          // We found it!\n          if (slider && slider.container) {\n            sliderContainer = slider.container;\n            slideIndexNumber = slider.getIndexNumber(index);\n            slide = slider.getSlide(index);\n          }\n\n          // Log 'em.\n          return logger.section({\n            heading: `🕹 Button ${num}`,\n            description: button,\n            groups: [\n              {\n                heading: '1. What slider is this button targeting?',\n                items: [\n                  { heading: 'Slider ID', description: sliderID },\n                  { heading: 'Slider Element', description: sliderContainer },\n                  { heading: 'Slider Object', description: slider || \"🤷‍♀️ We couldn't find any.\" },\n                ],\n              },\n              {\n                heading: '2. Which slide will it go to?',\n                items: [\n                  { heading: 'Slide Index', description: slideIndex },\n                  { heading: 'Slide Index (Number)', description: slideIndexNumber },\n                  { heading: 'Slide Element', description: slide },\n                ],\n              },\n            ],\n            collapsed: true,\n          });\n        }\n\n        // 2b. Navigation\n        if (nav) {\n          // Get details for the target slider\n          let sliderID = nav.getAttribute('data-snap-slider-nav');\n          const slider = window._SnapSliders[sliderID];\n          let buttons = qsa('[data-snap-slider-goto]', nav);\n\n          // \"We couldn't find anything.\"\n          sliderID = sliderID\n            ? `\"${sliderID}\"`\n            : `🤷‍♀️ We couldn't find any.\\n\n  • Include the slider ID you want to target in your \\`data-snap-slider-nav\\` attribute.\n      ◦ For example, \\`data-snap-slider-nav=\"example-slider\"\\`.`;\n\n          let sliderContainer = `🤷‍♀️ We couldn't find any.\\n\n  • Make sure the ID in your container's \\`data-snap-slider\\` attribute and the ID in your nav's \\`data-snap-slider-nav\\` attribute both match.`;\n\n          if (!buttons.length) {\n            buttons = `🤷‍♀️ We couldn't find any.\\n\n  • Make sure your buttons have a \\`data-snap-slider-goto\\` attribute.`;\n          }\n\n          // We found it!\n          if (slider && slider.container) {\n            sliderContainer = slider.container;\n          }\n\n          // Log 'em.\n          return logger.section({\n            heading: `🗺 Navigation ${num}`,\n            description: nav,\n            groups: [\n              {\n                heading: '1. What slider is this nav targeting?',\n                items: [\n                  { heading: 'Slider ID', description: sliderID },\n                  { heading: 'Slider Element', description: sliderContainer },\n                  { heading: 'Slider Object', description: slider || \"🤷‍♀️ We couldn't find any.\" },\n                ],\n              },\n              {\n                heading: '2. What buttons are in this nav?',\n                items: [{ heading: 'Buttons', description: buttons }],\n              },\n            ],\n            collapsed: true,\n          });\n        }\n\n        // 2c. Containers (aka sliders)\n        if (container) {\n          // Get details for the slider.\n          let sliderID = container.getAttribute('data-snap-slider');\n          const slider = window._SnapSliders[sliderID];\n          let navs = qsa(`[data-snap-slider-nav=\"${sliderID}\"]`);\n          let buttons = slider ? slider.getButtons() : [];\n\n          // \"We couldn't find anything.\"\n          sliderID = sliderID\n            ? `\"${sliderID}\"`\n            : `🤷‍♀️ We couldn't find any.\\n\n  • Include the slider ID you want in your \\`data-snap-slider\\` attribute.\n      ◦ For example, \\`data-snap-slider=\"example-slider\"\\`.`;\n\n          if (!navs.length) {\n            navs = `🤷‍♀️ We couldn't find any.\\n\n  • Make sure the ID in your container's \\`data-snap-slider\\` attribute and the ID in your nav's \\`data-snap-slider-nav\\` attribute both match.`;\n          }\n\n          if (!buttons.length) {\n            buttons = `🤷‍♀️ We couldn't find any.\\n\n  • Make sure your button is inside a \\`data-snap-slider-nav\\` element, or...\n  • Include the slider ID you want to target in your \\`data-snap-slider-goto\\` attribute.\n      ◦ For example, \\`data-snap-slider-goto=\"example-slider:prev\"\\`.`;\n          }\n\n          // Log 'em.\n          return logger.section({\n            heading: `🥨 Slider ${num}`,\n            description: container,\n            groups: [\n              {\n                heading: '1. What slider is this?',\n                items: [\n                  { heading: 'Slider ID', description: sliderID },\n                  { heading: 'Slider Object', description: slider || \"🤷‍♀️ We couldn't find any.\" },\n                ],\n              },\n              {\n                heading: '2. What navs target this slider?',\n                items: [{ heading: 'Navs', description: navs }],\n              },\n              {\n                heading: '3. What buttons target this slider?',\n                items: [{ heading: 'Buttons', description: buttons }],\n              },\n            ],\n            collapsed: true,\n          });\n        }\n\n        return SnapSlider.notFound(idOrElements);\n      });\n      /* eslint-enable no-irregular-whitespace */\n    }\n  }\n}\n\n// Keep track of all the sliders on the page to reference.\nwindow._SnapSliders = [];\n\n// Make the constructor globally accessible.\nwindow.SnapSlider = SnapSlider;\n\n// If jQuery exists, integrate.\nif (typeof $ !== 'undefined') {\n  // eslint-disable-next-line no-undef, func-names\n  $.fn.snapSlider = function (options) {\n    return new SnapSlider(this, options);\n  };\n}\n\n// Auto-init once the DOM is ready.\nonReady(() => {\n  // Init polyfills.\n  elementClosest(window);\n  smoothscroll.polyfill();\n\n  // Initialize all sliders with data attributes.\n  qsa('[data-snap-slider]').forEach((el) => new SnapSlider(el));\n\n  // Setup click events for *all* nav elements.\n  on('body', 'click', '[data-snap-slider-goto]', SnapSlider.handleGoto);\n});\n\nexport default SnapSlider;\n", "import hasOwnProperty from './hasOwnProperty';\n\n/**\n * Get a computed style for some element.\n * @param  {Element}  el\n * @param  {String}   prop\n * @return {String}\n */\nexport default function getStyle(el, prop) {\n  const style = window.getComputedStyle(el);\n\n  // Ignore mmissing elements or props\n  if (!style || !hasOwnProperty(style, prop)) {\n    return '';\n  }\n\n  return style[prop];\n}\n", "/**\n * Get an attribute for the closest element with it.\n * @param  {Element}  el\n * @param  {String}  attr\n * @return {String}\n */\nexport default function getClosestAttribute(el, attr) {\n  // Ignore missing elements\n  if (!el) {\n    return '';\n  }\n\n  // Find the closest element with a mattring attribute\n  el = el.closest(`[${attr}]`);\n\n  // If we found a match, return the attribute, otherwise\n  // return an empty string.\n  return el ? el.getAttribute(attr) : '';\n}\n", "/**\n * Wait to run a function on DOMContentLoaded, or fire immediately if the\n * event has already fired.\n * @param  {Function} fn\n * @return {void}\n */\nexport default function onReady(fn) {\n  if (document.readyState !== 'loading') {\n    fn();\n  } else {\n    document.addEventListener('DOMContentLoaded', fn);\n  }\n}\n", "/* eslint-disable consistent-return, func-names, no-var, prefer-arrow-callback, vars-on-top */\n\n/**\n * Plain JavaScript event delegation. Add a handler for whenever an element's\n * children trigger a specified event.\n * @see https://bdadam.com/blog/plain-javascript-event-delegation.html\n * @param  {String}    parentSelector\n * @param  {String}    eventName\n * @param  {String}    childSelector\n * @param  {Function}  fn\n * @return {Boolean}\n */\nexport default function on(parentSelector, eventName, childSelector, fn) {\n  var parent = document.querySelector(parentSelector);\n\n  if (!parent) {\n    return false;\n  }\n\n  parent.addEventListener(eventName, function (event) {\n    var possibleTargets = parent.querySelectorAll(childSelector);\n    var target = event.target;\n\n    for (var i = 0, l = possibleTargets.length; i < l; i += 1) {\n      var el = target;\n      var p = possibleTargets[i];\n\n      while (el && el !== parent) {\n        if (el === p) {\n          return fn.call(p, event);\n        }\n\n        el = el.parentNode;\n      }\n    }\n  });\n\n  return true;\n}\n\n// Example:\n// on('body', 'click', '.product', function(e) {\n//   console.log(e.target);\n// });\n", "/**\n * Return a string of dashes.\n *\n * @param  {Number}  num\n * @param  {String}  char\n * @return {String}\n */\nexport default function dashes(num, char = '-') {\n  let str = '';\n\n  for (let i = 0; i < num; i += 1) {\n    str += char;\n  }\n\n  return str;\n}\n", "/* eslint-disable indent */\n\n// Helpers\nimport dashes from '../helpers/dashes';\n\n/**\n * Get the substitution string for to format this value in a console.log.\n *\n * - %o = Object\n * - %d = Number (aka \"Digit\")\n * - %s = String\n * - %c = CSS\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions\n * @param  {mixed}   value\n * @return {String}\n */\nexport function getSubstitution(value) {\n  // Object\n  if (typeof value === 'object') {\n    return '%o';\n  }\n\n  // Number\n  if (typeof value === 'number') {\n    return '%d';\n  }\n\n  // When in doubt, assume everything else is a String.\n  return '%s';\n}\n\n/**\n * Log a full debug section.\n *\n * @param  {Object}  params\n * @param  {Object}  params.heading\n * @return {void}\n */\nexport function section(params) {\n  const {\n    heading,\n    description,\n    groups,\n    collapsed,\n  } = params;\n\n  // Allow groups to be collapsed.\n  const method = collapsed ? 'groupCollapsed' : 'group';\n\n  // HEADING\n  console.log(`%c\n┏━━${dashes(heading.length, '━')}━━┓\n┃  ${heading}  ┃\n┗━━${dashes(heading.length, '━')}━━┛`, 'font-size: 1.25em;', '\\n\\n',\n  description,\n  '\\n\\n');\n\n  // GROUPS\n  groups.forEach((group) => {\n    // Heading\n    console[method](`%c${group.heading}`, 'font-weight: bold;');\n\n    // Build up a single console.log for all the items in the group.\n    const args = [];\n    let content = '';\n\n    group.items.forEach((item) => {\n      // eslint-disable-next-line no-shadow\n      const { heading, description } = item;\n\n      // Heading\n      content += `\\n%c${getSubstitution(heading)}\\n`;\n      args.push('text-decoration: underline;', heading);\n\n      // Description\n      content += `\\n%c${getSubstitution(description)}\\n`;\n      args.push('text-decoration: none;', description);\n    });\n\n    // Log the items!\n    console.log(content, ...args);\n\n    // And end the group.\n    console.groupEnd();\n  });\n\n  // Add an empty line after the section.\n  console.log('\\n');\n}\n", "import SnapSlider from '@tannerhodges/snap-slider';\r\n\r\n//=======================================\r\n// Initialize lozad library\r\n//=======================================\r\nconst lozadObserver = lozad('.lozad', {\r\n  loaded: function(el) {\r\n    el.classList.add('fade');\r\n  },\r\n  error: function(el) {\r\n    console.log('Error loading image:', el);\r\n  }\r\n});\r\nlozadObserver.observe();\r\n\r\n//======================================\r\n// Initialize Snap slider\r\n//======================================\r\n// Create a new slider.\r\nconst slider = new SnapSlider('.flex-row-slider', {\r\n  id: 'media-slider-link',\r\n  nav: '.slider-nav',\r\n  start: 'first',\r\n});\r\n\r\n//======================================\r\n// Logo svg color toggle\r\n//======================================\r\nconst svgElement = document.getElementById(\"svgColor\");\r\n\r\nconst logoToggle = () => {\r\n  if (document.getElementById(\"prim-menu-checkbox\").checked) {\r\n    svgElement.classList.add(\"toggle-svg\");\r\n  } else {\r\n    svgElement.classList.remove(\"toggle-svg\");\r\n  }\r\n}\r\n\r\n//=====================================================\r\n// Show or hide contact buttons\r\n//=====================================================\r\nconst showBTNS = () => {\r\n  const element = document.getElementById(\"contactBTN\");\r\n  element.classList.toggle(\"hide\");\r\n}\r\n\r\nconst hideBTN = () => {\r\n  const element = document.getElementById(\"emailBTN\");\r\n  element.classList.toggle(\"hide\");\r\n}\r\n\r\nconst showBTNSpastor = () => {\r\n  const element = document.getElementById(\"contactBTNpastor\");\r\n  element.classList.toggle(\"hide\");\r\n}\r\n\r\nconst hideBTNpastor = () => {\r\n  const element = document.getElementById(\"emailBTNpastor\");\r\n  element.classList.toggle(\"hide\");\r\n}\r\n\r\n//=====================================================\r\n// Copy contact button\r\n//=====================================================\r\nconst contactEmailBtns = document.querySelectorAll('.js-emailcopybtn');\r\n\r\ncopyEmailBtn.addEventListener('click', function(event) {  \r\n  // Select the email link anchor text  \r\n  const emailLink = document.querySelector('.js-emaillink');\r\n  const selection = window.getSelection(); \r\n  const range = document.createRange();  \r\n  range.selectNode(emailLink);\r\n  selection.removeAllRanges();\r\n  selection.addRange(range);  \r\n\r\n  try {  \r\n    // Now that we've selected the anchor text, execute the copy command  \r\n    document.execCommand('copy');\r\n    selection.removeAllRanges();\r\n\r\n    const original = copyEmailBtn.textContent;\r\n    copyEmailBtn.textContent = 'Copied!';\r\n    copyEmailBtn.classList.add('success');\r\n\r\n    setTimeout(() => {\r\n      copyEmailBtn.textContent = original;\r\n      copyEmailBtn.classList.remove('success');\r\n    }, 1200);\r\n  } catch(e) {\r\n    const errorMsg = document.querySelector('.error-msg');\r\n    errorMsg.classList.add('show');\r\n\r\n    setTimeout(() => {\r\n      errorMsg.classList.remove('show');\r\n    }, 1200);\r\n  }\r\n});\r\n\r\n//=====================================================\r\n// Smooth scroll (plus polyfill)\r\n//=====================================================\r\nconst smoothLinks = document.querySelectorAll(\"nav ul a\");\r\n\r\nfor (const s_link of smoothLinks) {\r\n  s_link.addEventListener(\"click\", clickHandler);\r\n}\r\n\r\nfunction clickHandler(e) {\r\n  e.preventDefault();\r\n  const href = this.getAttribute(\"href\");\r\n  const offsetTop = document.querySelector(href).offsetTop;\r\n\r\n  window.scroll({\r\n    top: offsetTop,\r\n    behavior: \"smooth\"\r\n  });\r\n}\r\n\r\n//=======================================\r\n// Typing text animation\r\n//=======================================\r\nclass TxtType {\r\n  constructor(el, toRotate, period) {\r\n    this.toRotate = toRotate;\r\n    this.el = el;\r\n    this.loopNum = 0;\r\n    this.period = parseInt(period, 10) || 2000;\r\n    this.txt = '';\r\n    this.tick();\r\n    this.isDeleting = false;\r\n  }\r\n\r\n  tick() {\r\n    let i = this.loopNum % this.toRotate.length;\r\n    let fullTxt = this.toRotate[i];\r\n\r\n    if (this.isDeleting) {\r\n      this.txt = fullTxt.substring(0, this.txt.length - 1);\r\n    } else {\r\n      this.txt = fullTxt.substring(0, this.txt.length + 1);\r\n    }\r\n\r\n    this.el.innerHTML = '<span class=\"wrap\">'+this.txt+'</span>';\r\n\r\n    let that = this;\r\n    let delta = 200 - Math.random() * 100;\r\n\r\n    if (this.isDeleting) { delta /= 2; }\r\n\r\n    if (!this.isDeleting && this.txt === fullTxt) {\r\n      delta = this.period;\r\n      this.isDeleting = true;\r\n    } else if (this.isDeleting && this.txt === '') {\r\n      this.isDeleting = false;\r\n      this.loopNum++;\r\n      delta = 500;\r\n    }\r\n\r\n    setTimeout(() => {\r\n      that.tick();\r\n    }, delta);\r\n  }\r\n}\r\n\r\nwindow.onload = function() {\r\n  const elements = document.getElementsByClassName('typewrite');\r\n  for (let i = 0; i < elements.length; i++) {\r\n    const toRotate = elements[i].getAttribute('data-type');\r\n    const period = elements[i].getAttribute('data-period');\r\n    if (toRotate) {\r\n      new TxtType(elements[i], JSON.parse(toRotate), period);\r\n    }\r\n  }\r\n  // INJECT CSS\r\n  const css = document.createElement(\"style\");\r\n  css.type = \"text/css\";\r\n  css.innerHTML = \".typewrite > .wrap { border-right: 0.08em solid #f19426 }\";\r\n  document.body.appendChild(css);\r\n};\r\n"],
  "mappings": "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",
  "names": ["root", "factory", "exports", "module", "define", "amd", "window", "installedModules", "__webpack_require__", "moduleId", "i", "l", "modules", "call", "m", "c", "d", "name", "getter", "o", "Object", "defineProperty", "enumerable", "get", "r", "Symbol", "toStringTag", "value", "t", "mode", "__esModule", "ns", "create", "key", "bind", "n", "object", "property", "prototype", "hasOwnProperty", "p", "s", "type", "isObject", "now", "toNumber", "nativeMax", "Math", "max", "nativeMin", "min", "func", "wait", "options", "lastArgs", "lastThis", "maxWait", "result", "timerId", "lastCallTime", "lastInvokeTime", "leading", "maxing", "trailing", "TypeError", "invokeFunc", "time", "args", "thisArg", "apply", "leadingEdge", "setTimeout", "timerExpired", "shouldInvoke", "timeSinceLastCall", "trailingEdge", "timeWaiting", "debounced", "isInvoking", "arguments", "this", "clearTimeout", "cancel", "undefined", "flush", "debounce", "freeGlobal", "freeSelf", "self", "Function", "polyfill", "w", "document", "documentElement", "style", "__forceSmoothScrollPolyfill__", "userAgent", "Element", "HTMLElement", "original", "scroll", "scrollTo", "scrollBy", "elementScroll", "scrollElement", "scrollIntoView", "performance", "Date", "ROUNDING_TOLERANCE", "navigator", "RegExp", "join", "test", "shouldBailOut", "smoothScroll", "body", "left", "scrollX", "pageXOffset", "top", "scrollY", "pageYOffset", "scrollLeft", "scrollTop", "SyntaxError", "behavior", "scrollableParent", "findScrollableParent", "parentRects", "getBoundingClientRect", "clientRects", "getComputedStyle", "position", "x", "y", "firstArg", "hasScrollableSpace", "el", "axis", "clientHeight", "scrollHeight", "clientWidth", "scrollWidth", "canOverflow", "overflowValue", "isScrollable", "isScrollableY", "isScrollableX", "parentNode", "host", "step", "context", "currentX", "currentY", "k", "elapsed", "startTime", "cos", "PI", "startX", "startY", "method", "scrollable", "requestAnimationFrame", "candidateSelectors", "candidateSelector", "matches", "msMatchesSelector", "webkitMatchesSelector", "tabbable", "candidate", "candidateTabindex", "regularTabbables", "orderedTabbables", "candidates", "querySelectorAll", "includeContainer", "Array", "slice", "unshift", "length", "isNodeMatchingSelectorTabbable", "getTabindex", "push", "documentOrder", "tabIndex", "node", "sort", "sortOrderedTabbables", "map", "a", "concat", "isNodeMatchingSelectorFocusable", "isInput", "checked", "nodes", "ownerDocument", "disabled", "offsetParent", "visibility", "isTabbable", "Error", "isFocusable", "focusableCandidateSelector", "tabindexAttr", "parseInt", "getAttribute", "isNaN", "contentEditable", "b", "tagName", "e", "global", "g", "baseTrim", "isSymbol", "reIsBadHex", "reIsBinary", "reIsOctal", "freeParseInt", "other", "valueOf", "isBinary", "trimmedEndIndex", "reTrimStart", "string", "replace", "reWhitespace", "index", "charAt", "baseGetTag", "isObjectLike", "getRawTag", "objectToString", "symToStringTag", "objectProto", "nativeObjectToString", "toString", "isOwn", "tag", "unmasked", "ElementPrototype", "mozMatchesSelector", "selector", "elements", "Boolean", "closest", "element", "nodeType", "toArray", "val", "qsa", "getElements", "obj", "prop", "constructor", "minmax", "passive", "opts", "addEventListener", "removeEventListener", "error", "pick", "keys", "reduce", "values", "arr", "logger", "require", "counter", "SnapSlider", "containerOrOptions", "terms", "prev", "next", "callbacks", "init", "container", "watchForChanges", "_SnapSliders", "id", "indexOf", "button", "goto", "split", "str", "trim", "pop", "sliderID", "nav", "slider", "event", "target", "getButtonTarget", "console", "log", "idOrElements", "forEach", "num", "slideIndex", "isValidIndex", "sliderContainer", "slideIndexNumber", "slide", "getIndexNumber", "getSlide", "section", "heading", "description", "groups", "items", "collapsed", "buttons", "navs", "getButtons", "notFound", "slides", "start", "loop", "on", "shift", "eventName", "getMaybeSetID", "getMaybeSetSlides", "align", "getMaybeSetAlign", "current", "getMaybeSetStart", "getMaybeSetLoop", "transition", "scrolling", "navOptions", "addGotoButtons", "addNav", "update", "setAttribute", "children", "attr", "ceil", "getSnapAlign", "offsetTop", "offsetLeft", "offsetHeight", "offsetWidth", "focus", "force", "ignoreCallbacks", "immediate", "getScrollOffset", "startTransition", "fireEvent", "buildGoto", "from", "to", "diff", "abs", "stuck", "checkTransition", "stopTransition", "match", "textContent", "toLowerCase", "className", "isRelative", "buttonsOrOptions", "hasAttribute", "setGoto", "nextIndex", "isPrevButton", "isNextButton", "updateButtons", "filter", "isCurrent", "classList", "add", "remove", "removeAttribute", "tab", "navContainers", "navContainer", "offset", "scrollListener", "throttle", "getClosest", "scrollEndListener", "arrowKeyListener", "defaultPrevented", "isPrev", "isNext", "preventDefault", "focusListener", "contains", "resizeObserver", "observe", "disconnect", "ResizeObserver", "resizeCallback", "initialOptions", "hasLoaded", "updateSlides", "handleFocus", "events", "callback", "getCurrentSlide", "preventScroll", "activeElement", "$", "fn", "snapSlider", "readyState", "elementClosest", "smoothscroll", "parentSelector", "childSelector", "parent", "querySelector", "possibleTargets", "handleGoto", "dashes", "char", "getSubstitution", "params", "group", "content", "item", "groupEnd", "SnapSlider"]
}
